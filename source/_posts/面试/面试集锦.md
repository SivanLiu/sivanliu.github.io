---

title: Android/Java 面试锦囊

date:  2018-3-23 22:42:21

tags:  Android/Java

top: 30

---

# Android、Java 面试集锦

## 一、Android 面试

## 二、Java 面试
### 1. Java 基础：
#### 1. 请简述下 java 中 ==，equals，hashCode 的区别
##### a. 概念
* == ：操作符，生成的是一个 boolean 结果，它计算的是操作数的值之间的关系，针对于原生类型的比较；
* equals ： Object 的实例方法，比较两个对象的内容是否相同；
* hashCode ： Object 的 native方法，获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个 int 型整数；

##### b. 异同点：
* == 用来比较原生类型如：boolean、int、char 等等，而 equals() 则用来比较对象；
* 如果两个引用指向相同的对象，== 返回 true，equals() 的返回结果则依赖于具体的业务实现；
* 字符串的对比使用 equals() 代替 == 操作符；
* 如果两个对象 equals，则 hashcode 一定相等；
* 如果两个对象不 equals ，则 hashcode 可能相等；
* 如果两个对象 hashcode 相等，那么不一定 equals；
* 如果两个对象 hashcode 不相等，则一定不 equals

#### 2. int、char、long 各占多少字节数?

##### a. 基本数据类型：
| 类型 | 字节(byte) | bit 数 | 取值范围 | 封装类 |
| :---: | :---: | :---: | :---: | --- |
| int | 4 | 32 | -2147483648~2147483647 | Integer |
| short | 2 | 16 | -32768~32767 | Short |
| long | 8 | 64 | Long |
| byte | 1 | 8 | -128~127 | Byte |
| float | 4 | 32 | Float |
| double | 8 | 64 | Double |
| boolean | 1 | 8 | true、false | Boolean |
| char | 2 | 16 | Character |

##### b. int 与 integer 的区别（基本类型与其封装类的区别）：
* int 属于基本数据类型，放在栈中，直接存数值，而 integer 属于复杂数据类型对象；
* 在类进行初始化时 int 类的变量初始为 0，而 Integer 的变量则初始化为 null；
* 基本数据类型只能按值传递，而封装类按引用传递；
* 基本类型在堆栈中创建；而对于对象类型，对象在堆中创建，对象的引用在堆栈中创建。基本类型由于在堆栈中，效率会比较高，但是可能会存在内存泄漏的问题；

##### c. 有了基本类型，为什么还要使用封装类呢？
* 某些情况下，数据必须作为对象出现，此时必须使用封装类来将简单类型封装成对象。比如，如果想使用 List 来保存数值，由于 List 中只能添加对象，因此我们需要将数据封装到封装类中再加入 List。在 JDK5.0 以后可以自动封包，可以简写成 list.add(1) 的形式，但添加的数据依然是封装后的对象
* 某些情况下，自定义诸如 func(Object o) 的这种方法，它可以接受所有类型的对象数据，但对于简单数据类型，我们则必须使用封装类的对象
* 某些情况下，使用封装类使我们可以更加方便的操作数据。比如封装类具有一些基本类型不具备的方法，比如 valueOf()，toString()，以及方便的返回各种类型数据的方法，如 Integer 的 shortValue()，longValue()，intValue()等

#### 3. 谈谈你对 java 多态的理解
##### a. **多态的三个必要条件**：

* 继承
* 子类要重写父类的方法
* 父类引用指向子类对象

**下面看个例子：**

```java
//父类
public class Animal {
    int num = 10;
    static int age = 20;

    public void eat() {
        System.out.println("动物吃饭");
    }

    public static void sleep() {
        System.out.println("动物睡觉");
    }

    public void run() {
        System.out.println("动物奔跑");
    }
}

//子类
public class Dog extends Animal {
    int num = 100;
    static int age = 40;

    String name = "MyDog";

    public void eat() {
        System.out.println("小狗吃饭");
    }

    public static void sleep() {
        System.out.println("小狗睡觉");
    }

    public void playFootball() {
        System.out.println("小狗玩球");
    }
}

public class Polymorphism {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.eat();
        animal.sleep();
        animal.run();
        System.out.println("num = " + animal.num);
        System.out.println("age = " + animal.age);
        
//        System.out.println("age = " + animal.name);
//        animal.playFootball();
    }
}
```
**上述三段代码充分体现了多态的三个前提：**

* 继承：Dog 类继承了 Animal 类
* 子类要重写父类的方法：Dog 类重写了父类的 eat()，sleep() 两个成员方法，其中 eat() 是非静态的，sleep() 是静态的
* 父类数据的类型的引用指向子类对象：Polymorphism 中 Animal animal = new Dog()；语句在堆内存中开辟了子类 Dog 的对象，并把栈内存中的父类 Animal 的引用指向了 Dog 对象

**下面看看结果是什么？**

```groovy
小狗吃饭
动物睡觉
动物奔跑
num = 10
age = 20

Process finished with exit code 0
```
**可以看出来：**

* 子类 Dog 重写了父类 Animal 的非静态成员方法 animal.eat()；的输出结果为：小狗吃饭
* 子类重写了父类 Animal 的静态成员方法 animal.sleep()；的输出结果为：动物睡觉
* 未被子类 Dog 重写的父类 Animal 方法 animal.run()；输出结果为：动物奔跑
* 子类 Dog 重新定义了父类中的成员变量 num，age，输出结果为：10，20

**从上述结果可知：**

* 成员变量：编译看父类，运行看父类
* 非静态成员方法：编译看父类，运行看子类
* 静态成员方法：编译看父类，运行看父类

##### b. **那么多态有什么缺点吗？**
Polymorphism 中最后两行代码会报错，找不到 Dog 中的 name 和 playFootball
从上述结果可知，**多态后不能使用子类特有的成员属性和子类特有的成员方法**

如果想要在多态中访问特有的成员属性和方法，该怎么做呢？
**将父类引用指向子类对象 animal 再强制转回 Dog 类型后就可以访问 Dog 类中的所有属性和方法了。**

**修改后的代码如下：**

```java
public class Polymorphism {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.eat();
        animal.sleep();
        animal.run();
        System.out.println("num = " + animal.num);
        System.out.println("age = " + animal.age);

//        System.out.println("age = " + animal.name);
//        animal.playFootball();

        System.out.println("*****************************");
        Dog dog = (Dog) animal;
        dog.eat();
        dog.sleep();
        dog.run();
        System.out.println("num = " + dog.num);
        System.out.println("age = " + dog.age);

        System.out.println("age = " + dog.name);
        dog.playFootball();
    }
}
```

**结果：**

```groovy
小狗吃饭
动物睡觉
动物奔跑
num = 10
age = 20
*****************************
小狗吃饭
小狗睡觉
动物奔跑
num = 100
age = 40
age = MyDog
小狗玩球
```
现在 dog 就指向了最开始在堆内存中创建的 Dog 类型的对象了，尽管多态存在缺点，但优势十分明显。

##### c. **多态的优点主要有以下几个方面：**

- 消除类型之间的耦合关系 
- 可替换性：多态对已存在的代码具有可替换性。
- 可扩充性：多态对代码具有可扩充性，增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。
- 接口性：多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
- 灵活性：它在应用中体现了灵活多样的操作，提高了使用效率。
- 简化性：多态简化了对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。值得注意的是，多态并不能够解决提高执行速度的问题，因为它基于动态装载和地址引用，或称动态绑定。 










