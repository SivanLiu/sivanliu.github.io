---

title: Android/Java 面试锦囊

date:  2018-3-23 22:42:21

tags:  Android/Java

top: 30

---

# Android、Java 面试集锦

## 一、Android 面试

## 二、Java 面试
### 1. Java 基础：
#### 1. 请简述下 java 中 ==，equals，hashCode 的区别
##### a. 概念
* == ：操作符，生成的是一个 boolean 结果，它计算的是操作数的值之间的关系，针对于原生类型的比较；
* equals ： Object 的实例方法，比较两个对象的内容是否相同；
* hashCode ： Object 的 native方法，获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个 int 型整数；

##### b. 异同点：
* == 用来比较原生类型如：boolean、int、char 等等，而 equals() 则用来比较对象；
* 如果两个引用指向相同的对象，== 返回 true，equals() 的返回结果则依赖于具体的业务实现；
* 字符串的对比使用 equals() 代替 == 操作符；
* 如果两个对象 equals，则 hashcode 一定相等；
* 如果两个对象不 equals ，则 hashcode 可能相等；
* 如果两个对象 hashcode 相等，那么不一定 equals；
* 如果两个对象 hashcode 不相等，则一定不 equals

#### 2. int、char、long 各占多少字节数?

##### a. 基本数据类型：
| 类型 | 字节(byte) | bit 数 | 取值范围 | 封装类 |
| :---: | :---: | :---: | :---: | --- |
| int | 4 | 32 | -2147483648~2147483647 | Integer |
| short | 2 | 16 | -32768~32767 | Short |
| long | 8 | 64 | Long |
| byte | 1 | 8 | -128~127 | Byte |
| float | 4 | 32 | Float |
| double | 8 | 64 | Double |
| boolean | 1 | 8 | true、false | Boolean |
| char | 2 | 16 | Character |

##### b. int 与 integer 的区别（基本类型与其封装类的区别）：
* int 属于基本数据类型，放在栈中，直接存数值，而 integer 属于复杂数据类型对象；
* 在类进行初始化时 int 类的变量初始为 0，而 Integer 的变量则初始化为 null；
* 基本数据类型只能按值传递，而封装类按引用传递；
* 基本类型在堆栈中创建；而对于对象类型，对象在堆中创建，对象的引用在堆栈中创建。基本类型由于在堆栈中，效率会比较高，但是可能会存在内存泄漏的问题；

##### c. 有了基本类型，为什么还要使用封装类呢？
* 某些情况下，数据必须作为对象出现，此时必须使用封装类来将简单类型封装成对象。比如，如果想使用 List 来保存数值，由于 List 中只能添加对象，因此我们需要将数据封装到封装类中再加入 List。在 JDK5.0 以后可以自动封包，可以简写成 list.add(1) 的形式，但添加的数据依然是封装后的对象
* 某些情况下，自定义诸如 func(Object o) 的这种方法，它可以接受所有类型的对象数据，但对于简单数据类型，我们则必须使用封装类的对象
* 某些情况下，使用封装类使我们可以更加方便的操作数据。比如封装类具有一些基本类型不具备的方法，比如 valueOf()，toString()，以及方便的返回各种类型数据的方法，如 Integer 的 shortValue()，longValue()，intValue()等

#### 3. 谈谈你对 java 多态的理解
##### a. **多态的三个必要条件**：

* 继承
* 子类要重写父类的方法
* 父类引用指向子类对象

**下面看个例子：**

```java
//父类
public class Animal {
    int num = 10;
    static int age = 20;

    public void eat() {
        System.out.println("动物吃饭");
    }

    public static void sleep() {
        System.out.println("动物睡觉");
    }

    public void run() {
        System.out.println("动物奔跑");
    }
}

//子类
public class Dog extends Animal {
    int num = 100;
    static int age = 40;

    String name = "MyDog";

    public void eat() {
        System.out.println("小狗吃饭");
    }

    public static void sleep() {
        System.out.println("小狗睡觉");
    }

    public void playFootball() {
        System.out.println("小狗玩球");
    }
}

public class Polymorphism {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.eat();
        animal.sleep();
        animal.run();
        System.out.println("num = " + animal.num);
        System.out.println("age = " + animal.age);
        
//        System.out.println("age = " + animal.name);
//        animal.playFootball();
    }
}
```
**上述三段代码充分体现了多态的三个前提：**

* 继承：Dog 类继承了 Animal 类
* 子类要重写父类的方法：Dog 类重写了父类的 eat()，sleep() 两个成员方法，其中 eat() 是非静态的，sleep() 是静态的
* 父类数据的类型的引用指向子类对象：Polymorphism 中 Animal animal = new Dog()；语句在堆内存中开辟了子类 Dog 的对象，并把栈内存中的父类 Animal 的引用指向了 Dog 对象

**下面看看结果是什么？**

```groovy
小狗吃饭
动物睡觉
动物奔跑
num = 10
age = 20

Process finished with exit code 0
```
**可以看出来：**

* 子类 Dog 重写了父类 Animal 的非静态成员方法 animal.eat()；的输出结果为：小狗吃饭
* 子类重写了父类 Animal 的静态成员方法 animal.sleep()；的输出结果为：动物睡觉
* 未被子类 Dog 重写的父类 Animal 方法 animal.run()；输出结果为：动物奔跑
* 子类 Dog 重新定义了父类中的成员变量 num，age，输出结果为：10，20

**从上述结果可知：**

* 成员变量：编译看父类，运行看父类
* 非静态成员方法：编译看父类，运行看子类
* 静态成员方法：编译看父类，运行看父类

##### b. **那么多态有什么缺点吗？**
Polymorphism 中最后两行代码会报错，找不到 Dog 中的 name 和 playFootball
从上述结果可知，**多态后不能使用子类特有的成员属性和子类特有的成员方法**

如果想要在多态中访问特有的成员属性和方法，该怎么做呢？
**将父类引用指向子类对象 animal 再强制转回 Dog 类型后就可以访问 Dog 类中的所有属性和方法了。**

**修改后的代码如下：**

```java
public class Polymorphism {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.eat();
        animal.sleep();
        animal.run();
        System.out.println("num = " + animal.num);
        System.out.println("age = " + animal.age);

//        System.out.println("age = " + animal.name);
//        animal.playFootball();

        System.out.println("*****************************");
        Dog dog = (Dog) animal;
        dog.eat();
        dog.sleep();
        dog.run();
        System.out.println("num = " + dog.num);
        System.out.println("age = " + dog.age);

        System.out.println("age = " + dog.name);
        dog.playFootball();
    }
}
```

**结果：**

```groovy
小狗吃饭
动物睡觉
动物奔跑
num = 10
age = 20
*****************************
小狗吃饭
小狗睡觉
动物奔跑
num = 100
age = 40
age = MyDog
小狗玩球
```
现在 dog 就指向了最开始在堆内存中创建的 Dog 类型的对象了，尽管多态存在缺点，但优势十分明显。

##### c. **多态的优点主要有以下几个方面：**

- 消除类型之间的耦合关系 
- 可替换性：多态对已存在的代码具有可替换性。
- 可扩充性：多态对代码具有可扩充性，增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。
- 接口性：多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
- 灵活性：它在应用中体现了灵活多样的操作，提高了使用效率。
- 简化性：多态简化了对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。值得注意的是，多态并不能够解决提高执行速度的问题，因为它基于动态装载和地址引用，或称动态绑定。 

#### 4. String、StringBuffer、StringBuilder 区别

##### a. 定义：

* String: 字符串常量，使用 char[] 保存字符串，有 final 修饰，其对象不可变，对 String 对象的任何改变都不影响到原对象，相关的任何改变操作都会生成新的对象；
* StringBuffer: 字符串变量（Synchronized，即线程安全），继承自 AbstractStringBuilder 类，AbstractStringBuilder 中也是使用 char[] 来保存字符串；
* StringBuilder: 字符串变量，线程不安全，继承自 AbstractStringBuilder 类；

##### b. 使用场景：

* String：操作少量数据的情况下
* StringBuffer：多线程情况下操作大量数据 
* StringBuilder：单线程情况下操作大量数据

#### 5. 什么是内部类？说说内部类的作用？

##### a. 定义：
内部类是指定义在类的内部的类，主要分为以下几种：

###### 1）成员内部类
在外部类内部直接定义（不在方法内部或代码块内部）的类就是成员内部类，它可以直接使用外部类的所有变量和方法，即使是 private 的。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。

* 静态内部类：使用 static 修饰的成员内部类，除了访问权限修饰符比外围类多以外, 和外围类没有区别, 只是代码上将静态内部类组织在了外围类里面. 如果在外围类外部引用静态内部类, 需要带上外围类的名字
* 非静态内部类：没有 static 修饰的成员内部类

###### 2）局部内部类
局部内部类是在某个作用域或方法体内定义的内部类，局部内部类不能有 private 等访问说明符

###### 3）匿名内部类
匿名内部类则用来创建一个继承自某个基类的匿名类的对象，并向上转型为该基类的引用。
* 匿名内部类不能是抽象类：匿名内部类创建时，会立即创建匿名内部类的对象
* 匿名内部类不能定义构造器：无类名，无法定义构造器，但可定义初始化块

###### 4）匿名内部类与 Lambda：

* Lambda 表达式的目标类型必须是明确的函数式接口
* Lambda 表达式只能为函数式接口创建对象

**Lambda 常见方式：**

* 将 Lambda 表达式赋值给函数式接口类型的变量
* 将 Lambda 表达式作为函数式接口类型的参数传给某个方法
* 使用函数式接口对 Lambda 表达式进行强制类型转换

**Lambda 表达式支持的方法引用和构造器引用**

| 种类 | 示例 | 说明 | 对应的 Lambda 表达式 |
| :-- | :-- | :-- | :-- |
| 引用类方法 | 类名::类方法 | 函数式接口中被实现方法的全部参数传给该类方法作为参数 | (a, b...)-> 类名.类方法(a, b...)  |
| 引用特定对象的实例方法 | 特定对象::实例方法 | 函数式接口中被实现方法的全部参数传给该方法作为参数 | (a, b...)-> 特定对象.实例方法(a, b,...) |
| 引用某类对象的实例方法 | 类型::实例方法 | 函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为采纳数 | (a, b...)-> a.实例方法(b,...) |
| 引用构造器 | 类名::new | 函数式接口中被实现方法的全部参数传给该构造器作为参数 | (a, b...)-> new 类名(a, b,...) |

**Lambda 表达式与匿名内部类的主要区别**：

* 匿名内部类可以为任意接口创建实例，但 Lambda 只能为函数式接口创建实例；
* 匿名内部类可以为抽象类甚至普通类创建实例，但 Lambda 表达式只能为函数式接口创建实例；
* 匿名内部类实现抽象方法的方法允许调用接口中定义的默认方法，但 Lambda 表达式的代码不允许调用接口中定义的默认方法

###### 6）内部类与外部类语法区别：

* 内部类比外部类可以多使用三个修饰符：private/protected/static
* 非静态内部类不能拥有静态成员

##### b. 作用：

* 可以用来实现“多重继承”，弥补了单继承的缺陷；
* 内部类可以有多个实例，每个对象都与外围类相互独立；
* 可以让多个内部类以不同的方式实现同一个接口，或继承同一个类；
* 创建内部类对象的时刻并不依赖于外围类对象的创建；
* 内部类可以直接或利用引用访问外部类的属性和方法，包括私有属性和方法（但静态内部类不能访问外部类的非静态成员变量和方法）
* 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
* 内容类成员可以直接访问外部类的私有数据，因为内部类被当做其外部类成员，同一个类的成员之间可以相互访问，但外部类不能访问内部类的实现细节，如内部类的成员变量
* 匿名内部类适合用于创建那些仅需要一次使用的类

#### 6. 抽象类和接口区别，抽象类的意义，抽象类是否可以没有方法和属性？

* 均不能被实例化 不能直接实例化 多态实例化其子类
* 接口抽象级别高于抽象类
* 接口只能声明方法，抽象类既可以声明方法也可以实现方法
* 抽象类内可以没有抽象方法，抽象方法不能是静态以及私有的
* 抽象类单继承，接口多实现


#### 7. 泛型中 extends 和 super 的区别
* extends：表示包括 T 在内的任何 T 的父类 下界通配符
* super：表示包括 T 在内的任何 T 的子类 上界通配符

#### 8. 父类的静态方法能否被子类重写
可被继承 不能被重写
静态方法从程序开始运行后就已经分配了内存,子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法。

#### 9. 进程和线程的区别

进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。
进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。
一个进程内可拥有多个线程，进程可开启进程，也可开启线程。
一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。

#### 10. final，finally，finalize的区别

final:修饰类、成员变量和成员方法，类不可被继承，成员变量不可变，成员方法不可重写
finally:与try...catch...共同使用，确保无论是否出现异常都能被调用到
finalize:类的方法,垃圾回收之前会调用此方法,子类可以重写finalize()方法实现对资源的回收

#### 11. 序列化的方式，Serializable 和 Parcelable 的区别

static、trasient修饰的变量不可被序列化
若一个类可序列化，其子类，内部类都要可序列化
序列化的定义：任何数据都是以二进制的形式存贮到硬盘或是在网络上传送，而Java为了能将Java对象存贮到硬盘上或在网络上传送，把Java对象转换成字节流进行传输，这个转换过程就称之为Java序列化。Java --> 二进制字节流。

Serializable Java 序列化接口 在硬盘上读写 读写过程中有大量临时变量的生成
Parcelable Android 序列化接口 效率高 使用麻烦 在内存中读写（AS有相关插件 一键生成所需方法）









